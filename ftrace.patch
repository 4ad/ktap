diff --git a/include/linux/ftrace_event.h b/include/linux/ftrace_event.h
index a3d4895..7b5a424 100644
--- a/include/linux/ftrace_event.h
+++ b/include/linux/ftrace_event.h
@@ -168,6 +168,7 @@ struct ftrace_event_class {
 #ifdef CONFIG_PERF_EVENTS
 	void			*perf_probe;
 #endif
+	void			*ktap_probe; /* for ktap */
 	int			(*reg)(struct ftrace_event_call *event,
 				       enum trace_reg type, void *data);
 	int			(*define_fields)(struct ftrace_event_call *);
@@ -232,6 +233,11 @@ struct ftrace_event_call {
 	int				perf_refcount;
 	struct hlist_head __percpu	*perf_events;
 #endif
+	int				ktap_refcount;
+	struct hlist_head		ktap_callback_list;
+	void *(*ktap_pre_trace)(struct ftrace_event_call *call, int size, unsigned long *flags);
+	void (*ktap_do_trace)(struct ftrace_event_call *call, void *entry, int entry_size, int data_size);
+	void (*ktap_post_trace)(struct ftrace_event_call *call, void *entry, unsigned long *flags);
 };
 
 #define __TRACE_EVENT_FLAGS(name, value)				\
@@ -274,6 +280,9 @@ extern void trace_remove_event_call(struct ftrace_event_call *call);
 
 #define is_signed_type(type)	(((type)(-1)) < 0)
 
+typedef void (*ftrace_call_func)(struct ftrace_event_call * call, void *data);
+void ftrace_on_event_call(char *buf, ftrace_call_func actor, void *data);
+
 int trace_set_clr_event(const char *system, const char *event, int set);
 
 /*
diff --git a/include/trace/ftrace.h b/include/trace/ftrace.h
index 40dc5e8..aeef0b6 100644
--- a/include/trace/ftrace.h
+++ b/include/trace/ftrace.h
@@ -486,6 +486,14 @@ static inline notrace int ftrace_get_offsets_##call(			\
 #define _TRACE_PERF_INIT(call)
 #endif /* CONFIG_PERF_EVENTS */
 
+
+#define _TRACE_KTAP_PROTO(call, proto)					\
+	static notrace void						\
+	ktap_trace_##call(void *__data, proto);
+
+#define _TRACE_KTAP_INIT(call)						\
+	.ktap_probe		= ktap_trace_##call,
+
 #undef __entry
 #define __entry entry
 
@@ -580,6 +588,7 @@ static inline void ftrace_test_probe_##call(void)			\
 #undef DECLARE_EVENT_CLASS
 #define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\
 _TRACE_PERF_PROTO(call, PARAMS(proto));					\
+_TRACE_KTAP_PROTO(call, PARAMS(proto));					\
 static const char print_fmt_##call[] = print;				\
 static struct ftrace_event_class __used event_class_##call = {		\
 	.system			= __stringify(TRACE_SYSTEM),		\
@@ -589,6 +598,7 @@ static struct ftrace_event_class __used event_class_##call = {		\
 	.probe			= ftrace_raw_event_##call,		\
 	.reg			= ftrace_event_reg,			\
 	_TRACE_PERF_INIT(call)						\
+	_TRACE_KTAP_INIT(call)						\
 };
 
 #undef DEFINE_EVENT
@@ -705,5 +715,82 @@ static inline void perf_test_probe_##call(void)				\
 #include TRACE_INCLUDE(TRACE_INCLUDE_FILE)
 #endif /* CONFIG_PERF_EVENTS */
 
+
+/* KTAP */
+#undef __entry
+#define __entry entry
+
+#undef __get_dynamic_array
+#define __get_dynamic_array(field)	\
+		((void *)__entry + (__entry->__data_loc_##field & 0xffff))
+
+#undef __get_str
+#define __get_str(field) (char *)__get_dynamic_array(field)
+
+#undef TP_fast_assign
+#define TP_fast_assign(args...) args
+
+#undef TP_perf_assign
+#define TP_perf_assign(args...)
+
+#undef TP_printk
+
+extern void ktap_do_trace(struct ftrace_event_call *call, void *entry, int entry_size, int data_size);
+
+#undef DECLARE_EVENT_CLASS
+#define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\
+static notrace void							\
+ktap_trace_##call(void *__data, proto)					\
+{									\
+	struct ftrace_event_call *event_call = __data;			\
+	struct ftrace_data_offsets_##call __maybe_unused __data_offsets;\
+	struct ftrace_raw_##call *entry;				\
+	int __data_size;						\
+	unsigned long ktap_flags;						\
+									\
+	__data_size = ftrace_get_offsets_##call(&__data_offsets, args); \
+									\
+	entry = event_call->ktap_pre_trace(event_call, sizeof(*entry) + __data_size, &ktap_flags); \
+									\
+	if (unlikely(!entry))						\
+		return;							\
+	tstruct								\
+									\
+	{ assign; }							\
+									\
+	event_call->ktap_do_trace(event_call, (void *)entry, sizeof(struct ftrace_raw_##call), __data_size);\
+	event_call->ktap_post_trace(event_call, entry, &ktap_flags);			\
+	return;								\
+}
+
+/*
+ * This part is compiled out, it is only here as a build time check
+ * to make sure that if the tracepoint handling changes, the
+ * ktap probe will fail to compile unless it too is updated.
+ */
+#undef DEFINE_EVENT
+#define DEFINE_EVENT(template, call, proto, args)			\
+static inline void ktap_test_probe_##call(void)				\
+{									\
+	check_trace_callback_type_##call(ktap_trace_##template);	\
+}
+
+
+#undef DEFINE_EVENT_PRINT
+#define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\
+	DEFINE_EVENT(template, name, PARAMS(proto), PARAMS(args))
+
+#undef TRACE_EVENT
+#define TRACE_EVENT(name, proto, args, tstruct, assign, print) \
+	DECLARE_EVENT_CLASS(name,			       \
+			     PARAMS(proto),		       \
+			     PARAMS(args),		       \
+			     PARAMS(tstruct),		       \
+			     PARAMS(assign),		       \
+			     PARAMS(print));		       \
+	DEFINE_EVENT(name, name, PARAMS(proto), PARAMS(args));
+
+#include TRACE_INCLUDE(TRACE_INCLUDE_FILE)
+
 #undef _TRACE_PROFILE_INIT
 
diff --git a/include/trace/syscall.h b/include/trace/syscall.h
index 84bc419..3d88f63 100644
--- a/include/trace/syscall.h
+++ b/include/trace/syscall.h
@@ -31,4 +31,6 @@ struct syscall_metadata {
 	struct ftrace_event_call *exit_event;
 };
 
+struct syscall_metadata *syscall_nr_to_meta(int nr);
+
 #endif /* _TRACE_SYSCALL_H */
diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c
index 880073d..4da5f57 100644
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -279,6 +279,62 @@ static void put_system(struct event_subsystem *system)
 	mutex_unlock(&event_mutex);
 }
 
+typedef void (*ftrace_call_func)(struct ftrace_event_call *, void *data);
+void ftrace_on_event_call(char *buf, ftrace_call_func actor, void *data)
+{
+	char *event = NULL, *sub = NULL, *match;
+	struct ftrace_event_call *call;
+
+	/*
+	 * The buf format can be <subsystem>:<event-name>
+	 *  *:<event-name> means any event by that name.
+	 *  :<event-name> is the same.
+	 *
+	 *  <subsystem>:* means all events in that subsystem
+	 *  <subsystem>: means the same.
+	 *
+	 *  <name> (no ':') means all events in a subsystem with
+	 *  the name <name> or any event that matches <name>
+	 */
+
+	match = strsep(&buf, ":");
+	if (buf) {
+		sub = match;
+		event = buf;
+		match = NULL;
+
+		if (!strlen(sub) || strcmp(sub, "*") == 0)
+			sub = NULL;
+		if (!strlen(event) || strcmp(event, "*") == 0)
+			event = NULL;
+	}
+
+	mutex_lock(&event_mutex);
+	list_for_each_entry(call, &ftrace_events, list) {
+
+		if (!call->name || !call->class || !call->class->reg)
+			continue;
+
+		if (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)
+			continue;
+
+		if (match &&
+		    strcmp(match, call->name) != 0 &&
+		    strcmp(match, call->class->system) != 0)
+			continue;
+
+		if (sub && strcmp(sub, call->class->system) != 0)
+			continue;
+
+		if (event && strcmp(event, call->name) != 0)
+			continue;
+
+		(*actor)(call, data);
+	}
+	mutex_unlock(&event_mutex);
+}
+EXPORT_SYMBOL_GPL(ftrace_on_event_call);
+
 /*
  * __ftrace_set_clr_event(NULL, NULL, NULL, set) will set/unset all events.
  */
diff --git a/kernel/trace/trace_syscalls.c b/kernel/trace/trace_syscalls.c
index 7609dd6..3e96498 100644
--- a/kernel/trace/trace_syscalls.c
+++ b/kernel/trace/trace_syscalls.c
@@ -69,13 +69,14 @@ find_syscall_meta(unsigned long syscall)
 	return NULL;
 }
 
-static struct syscall_metadata *syscall_nr_to_meta(int nr)
+struct syscall_metadata *syscall_nr_to_meta(int nr)
 {
 	if (!syscalls_metadata || nr >= NR_syscalls || nr < 0)
 		return NULL;
 
 	return syscalls_metadata[nr];
 }
+EXPORT_SYMBOL_GPL(syscall_nr_to_meta);
 
 enum print_line_t
 print_syscall_enter(struct trace_iterator *iter, int flags,
